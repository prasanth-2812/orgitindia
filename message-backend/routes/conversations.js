const express = require('express');
const pool = require('../database/db');
const { authenticateToken } = require('../middleware/auth');

const router = express.Router();

// Get all conversations (with pinned first)
router.get('/', authenticateToken, async (req, res) => {
  try {
    const userId = req.user.userId;

    const result = await pool.query(
      `SELECT 
        c.id,
        c.name,
        c.is_group,
        c.is_task_group,
        c.group_photo,
        c.created_at,
        cm.is_pinned,
        cm.role,
        (
          SELECT json_agg(
            json_build_object(
              'id', u.id,
              'name', u.name,
              'phone', u.phone,
              'profile_photo', u.profile_photo
            )
          )
          FROM conversation_members cm2
          JOIN users u ON cm2.user_id = u.id
          WHERE cm2.conversation_id = c.id AND cm2.user_id != $1
        ) as other_members,
        (
          SELECT json_build_object(
            'id', m.id,
            'content', m.content,
            'message_type', m.message_type,
            'sender_id', m.sender_id,
            'sender_name', u.name,
            'status', m.status,
            'created_at', m.created_at,
            'deleted_at', m.deleted_at,
            'deleted_for_all', m.deleted_for_all
          )
          FROM messages m
          JOIN users u ON m.sender_id = u.id
          WHERE m.conversation_id = c.id AND m.deleted_at IS NULL
          ORDER BY m.created_at DESC
          LIMIT 1
        ) as last_message,
        (
          SELECT created_at
          FROM messages
          WHERE conversation_id = c.id AND deleted_at IS NULL
          ORDER BY created_at DESC
          LIMIT 1
        ) as last_message_time,
        (
          SELECT COUNT(*)
          FROM messages
          WHERE conversation_id = c.id
          AND sender_id != $1
          AND status != 'read'
          AND deleted_at IS NULL
        ) as unread_count
      FROM conversations c
      INNER JOIN conversation_members cm ON c.id = cm.conversation_id
      WHERE cm.user_id = $1
      ORDER BY cm.is_pinned DESC, last_message_time DESC NULLS LAST, c.created_at DESC`,
      [userId]
    );

    res.json({ conversations: result.rows });
  } catch (error) {
    console.error('Get conversations error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Create or get 1-to-1 conversation
router.post('/create', authenticateToken, async (req, res) => {
  try {
    const userId = req.user.userId;
    const { otherUserId } = req.body;
    const io = req.app.get('io'); // Get Socket.IO instance

    if (!otherUserId) {
      return res.status(400).json({ error: 'otherUserId is required' });
    }

    if (userId === otherUserId) {
      return res.status(400).json({ error: 'Cannot create conversation with yourself' });
    }

    // Check if conversation already exists (non-group, non-task)
    const existing = await pool.query(
      `SELECT c.id
       FROM conversations c
       INNER JOIN conversation_members cm1 ON c.id = cm1.conversation_id
       INNER JOIN conversation_members cm2 ON c.id = cm2.conversation_id
       WHERE cm1.user_id = $1 AND cm2.user_id = $2 AND c.is_group = FALSE`,
      [userId, otherUserId]
    );

    let conversationId;
    let isNewConversation = false;

    if (existing.rows.length > 0) {
      conversationId = existing.rows[0].id;
    } else {
      // Create new conversation
      const client = await pool.connect();
      try {
        await client.query('BEGIN');

        const convResult = await client.query(
          'INSERT INTO conversations (is_group, created_by) VALUES (FALSE, $1) RETURNING id',
          [userId]
        );
        conversationId = convResult.rows[0].id;

        await client.query(
          'INSERT INTO conversation_members (conversation_id, user_id, role) VALUES ($1, $2, $3)',
          [conversationId, userId, 'member']
        );

        await client.query(
          'INSERT INTO conversation_members (conversation_id, user_id, role) VALUES ($1, $2, $3)',
          [conversationId, otherUserId, 'member']
        );

        await client.query('COMMIT');
        isNewConversation = true;
      } catch (error) {
        await client.query('ROLLBACK');
        throw error;
      } finally {
        client.release();
      }
    }

    // Automatically join both users to the conversation room if they're online
    if (io && conversationId) {
      // Join creator to room
      const creatorSockets = await io.in(`user_${userId}`).fetchSockets();
      for (const socket of creatorSockets) {
        socket.join(conversationId);
        console.log(`User ${userId} auto-joined conversation room ${conversationId}`);
      }

      // Join other user to room
      const otherUserSockets = await io.in(`user_${otherUserId}`).fetchSockets();
      for (const socket of otherUserSockets) {
        socket.join(conversationId);
        console.log(`User ${otherUserId} auto-joined conversation room ${conversationId}`);
      }

      // Notify both users about the new conversation (if it's new)
      if (isNewConversation) {
        io.to(`user_${userId}`).emit('conversation_created', { conversationId });
        io.to(`user_${otherUserId}`).emit('conversation_created', { conversationId });
      }
    }

    res.status(isNewConversation ? 201 : 200).json({ conversationId });
  } catch (error) {
    console.error('Create conversation error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Create manual group
router.post('/groups/create', authenticateToken, async (req, res) => {
  try {
    const userId = req.user.userId;
    const { name, memberIds, group_photo } = req.body;

    if (!name || !Array.isArray(memberIds) || memberIds.length === 0) {
      return res.status(400).json({ error: 'Group name and at least one member required' });
    }

    // Add creator to members if not included
    if (!memberIds.includes(userId)) {
      memberIds.push(userId);
    }

    const client = await pool.connect();
    try {
      await client.query('BEGIN');

      // Create group conversation
      const convResult = await client.query(
        `INSERT INTO conversations (name, is_group, group_photo, created_by)
         VALUES ($1, TRUE, $2, $3)
         RETURNING id`,
        [name, group_photo || null, userId]
      );
      const conversationId = convResult.rows[0].id;

      // Add members (creator as admin, others as members)
      for (const memberId of memberIds) {
        await client.query(
          `INSERT INTO conversation_members (conversation_id, user_id, role)
           VALUES ($1, $2, $3)`,
          [conversationId, memberId, memberId === userId ? 'admin' : 'member']
        );
      }

      await client.query('COMMIT');

      res.status(201).json({ conversationId });
    } catch (error) {
      await client.query('ROLLBACK');
      throw error;
    } finally {
      client.release();
    }
  } catch (error) {
    console.error('Create group error:', error);
    res.status(500).json({ error: 'Failed to create group' });
  }
});

// Create auto task group
router.post('/groups/task-group', authenticateToken, async (req, res) => {
  try {
    const userId = req.user.userId;
    const { taskId, name, memberIds } = req.body;

    if (!taskId || !name || !Array.isArray(memberIds)) {
      return res.status(400).json({ error: 'Task ID, name, and member IDs required' });
    }

    const client = await pool.connect();
    try {
      await client.query('BEGIN');

      // Create task group conversation
      const convResult = await client.query(
        `INSERT INTO conversations (name, is_group, is_task_group, task_id, created_by)
         VALUES ($1, TRUE, TRUE, $2, $3)
         RETURNING id`,
        [name, taskId, userId]
      );
      const conversationId = convResult.rows[0].id;

      // Add creator and assigned members
      const allMembers = [userId, ...memberIds];
      for (const memberId of allMembers) {
        await client.query(
          `INSERT INTO conversation_members (conversation_id, user_id, role)
           VALUES ($1, $2, $3)
           ON CONFLICT DO NOTHING`,
          [conversationId, memberId, memberId === userId ? 'admin' : 'member']
        );
      }

      await client.query('COMMIT');

      res.status(201).json({ conversationId });
    } catch (error) {
      await client.query('ROLLBACK');
      throw error;
    } finally {
      client.release();
    }
  } catch (error) {
    console.error('Create task group error:', error);
    res.status(500).json({ error: 'Failed to create task group' });
  }
});

// Add members to group
router.post('/groups/:conversationId/members', authenticateToken, async (req, res) => {
  try {
    const userId = req.user.userId;
    const { conversationId } = req.params;
    const { memberIds } = req.body;

    if (!Array.isArray(memberIds) || memberIds.length === 0) {
      return res.status(400).json({ error: 'Member IDs array required' });
    }

    // Verify user is member of group
    const memberCheck = await pool.query(
      'SELECT role FROM conversation_members WHERE conversation_id = $1 AND user_id = $2',
      [conversationId, userId]
    );

    if (memberCheck.rows.length === 0) {
      return res.status(403).json({ error: 'Not a member of this group' });
    }

    // Verify it's a group
    const convCheck = await pool.query(
      'SELECT is_group FROM conversations WHERE id = $1',
      [conversationId]
    );

    if (!convCheck.rows[0]?.is_group) {
      return res.status(400).json({ error: 'Not a group conversation' });
    }

    // Add members
    for (const memberId of memberIds) {
      await pool.query(
        `INSERT INTO conversation_members (conversation_id, user_id, role)
         VALUES ($1, $2, 'member')
         ON CONFLICT DO NOTHING`,
        [conversationId, memberId]
      );
    }

    res.json({ success: true, added: memberIds.length });
  } catch (error) {
    console.error('Add members error:', error);
    res.status(500).json({ error: 'Failed to add members' });
  }
});

// Remove member from group
router.delete('/groups/:conversationId/members/:memberId', authenticateToken, async (req, res) => {
  try {
    const userId = req.user.userId;
    const { conversationId, memberId } = req.params;

    // Verify user is member
    const memberCheck = await pool.query(
      'SELECT role FROM conversation_members WHERE conversation_id = $1 AND user_id = $2',
      [conversationId, userId]
    );

    if (memberCheck.rows.length === 0) {
      return res.status(403).json({ error: 'Not a member of this group' });
    }

    // Remove member (any member can remove, but can't remove admin)
    if (memberId === userId) {
      return res.status(400).json({ error: 'Cannot remove yourself' });
    }

    await pool.query(
      'DELETE FROM conversation_members WHERE conversation_id = $1 AND user_id = $2',
      [conversationId, memberId]
    );

    res.json({ success: true });
  } catch (error) {
    console.error('Remove member error:', error);
    res.status(500).json({ error: 'Failed to remove member' });
  }
});

// Update group (name, photo) - admin only
router.put('/groups/:conversationId', authenticateToken, async (req, res) => {
  try {
    const userId = req.user.userId;
    const { conversationId } = req.params;
    const { name, group_photo } = req.body;

    // Verify user is admin
    const memberCheck = await pool.query(
      'SELECT role FROM conversation_members WHERE conversation_id = $1 AND user_id = $2',
      [conversationId, userId]
    );

    if (memberCheck.rows.length === 0 || memberCheck.rows[0].role !== 'admin') {
      return res.status(403).json({ error: 'Only group admin can update group' });
    }

    const updates = [];
    const values = [];
    let paramCount = 1;

    if (name) {
      updates.push(`name = $${paramCount++}`);
      values.push(name);
    }
    if (group_photo !== undefined) {
      updates.push(`group_photo = $${paramCount++}`);
      values.push(group_photo);
    }

    if (updates.length === 0) {
      return res.status(400).json({ error: 'No updates provided' });
    }

    updates.push(`updated_at = CURRENT_TIMESTAMP`);
    values.push(conversationId);

    await pool.query(
      `UPDATE conversations SET ${updates.join(', ')} WHERE id = $${paramCount}`,
      values
    );

    res.json({ success: true });
  } catch (error) {
    console.error('Update group error:', error);
    res.status(500).json({ error: 'Failed to update group' });
  }
});

// Pin/Unpin conversation
router.put('/:conversationId/pin', authenticateToken, async (req, res) => {
  try {
    const userId = req.user.userId;
    const { conversationId } = req.params;
    const { is_pinned } = req.body;

    await pool.query(
      `UPDATE conversation_members
       SET is_pinned = $1
       WHERE conversation_id = $2 AND user_id = $3`,
      [is_pinned === true, conversationId, userId]
    );

    res.json({ success: true });
  } catch (error) {
    console.error('Pin conversation error:', error);
    res.status(500).json({ error: 'Failed to pin conversation' });
  }
});

// Get conversation details
router.get('/:conversationId', authenticateToken, async (req, res) => {
  try {
    const userId = req.user.userId;
    const { conversationId } = req.params;

    // Verify user is member
    const memberCheck = await pool.query(
      'SELECT role, is_pinned FROM conversation_members WHERE conversation_id = $1 AND user_id = $2',
      [conversationId, userId]
    );

    if (memberCheck.rows.length === 0) {
      return res.status(403).json({ error: 'Not a member of this conversation' });
    }

    // Get conversation details
    const convResult = await pool.query(
      'SELECT * FROM conversations WHERE id = $1',
      [conversationId]
    );

    // Get members with roles
    const membersResult = await pool.query(
      `SELECT u.id, u.name, u.phone, u.profile_photo, cm.role, cm.joined_at
       FROM conversation_members cm
       JOIN users u ON cm.user_id = u.id
       WHERE cm.conversation_id = $1
       ORDER BY cm.role DESC, cm.joined_at ASC`,
      [conversationId]
    );

    res.json({
      conversation: convResult.rows[0],
      members: membersResult.rows,
      userRole: memberCheck.rows[0].role,
      isPinned: memberCheck.rows[0].is_pinned,
    });
  } catch (error) {
    console.error('Get conversation error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Backwards-compatible: Get all users (for creating new 1-to-1 conversations)
router.get('/users/list', authenticateToken, async (req, res) => {
  try {
    const userId = req.user.userId;

    const result = await pool.query(
      'SELECT id, name, phone FROM users WHERE id != $1 ORDER BY name',
      [userId]
    );

    res.json({ users: result.rows });
  } catch (error) {
    console.error('Get users error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

module.exports = router;

